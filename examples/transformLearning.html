<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Transform Learning</title>

    <style type="text/css">
        *{padding: 0;margin:0;}
        body{background: #1b1b1b;}
        #div1{margin:50px auto; width:800px; height: 800px;}
        canvas{background: #fff;}
    </style>
    <script type="text/javascript" src="../src/XIE.js"></script>
    <script type="text/javascript" src="../src/helpers/matrix.js"></script>
    <script type="text/javascript">

        var matrix = XIE.matrix;
        window.onload = function(){

            draw();
        };

        function draw(){

            var kk ='k0.';
            var qq = Object.prototype.toString.call(kk);
            var ii = parseInt(kk);
            var jj = parseFloat(kk);

            var oo = Math.round(ii);
            var pp = Math.round(jj);

            var c = document.getElementById('myCanvas');
            var ctx = c.getContext('2d');
            /*ctx.translate(200,20);

            for(var i=0; i<30; i++){
                ctx.save();
                ctx.transform(0.95,0,0,0.95,30,30);
                ctx.rotate(Math.PI/12);
                ctx.beginPath();
                ctx.fillStyle = 'red';
                ctx.globalAlpha = '0.4';
                ctx.arc(0,0,50,0,Math.PI*2,true);
                ctx.closePath();
                ctx.fill();
            }*/




            ctx.globalAlpha = '0.4';
            var width =50, height =50,
            originX=400, originY=400,
            offsetX = 0/*-width/2*/, offsetY = 100/*-height/2*/,
                    scaleX=2, scaleY=2;




         /*   ctx.transform(1,0,0,1,originX,originY);    //将前面的矩阵恢复为最初的矩阵，即恢复最初的原点，然后将坐标原点改为(10,10),并以新的坐标绘制一个蓝色的矩形

            ctx.transform(1,0,0,1,offSetX,offSetY);
            ctx.fillStyle = 'blue';
            ctx.fillRect(0,0,width,height);
            ctx.fill();*/
            ctx.setTransform(1,0,0,1,originX,originY);
            rect(width,height,'blue');


            var a= 30,increase = 30;
            var m1 = [1,0,0,1,0,0], m2= [1,0,0,1,0,0], mFinal = [1,0,0,1,0,0],mScale=[], mRotate=[],mTrans=[];
            mScale = [scaleX,0,0,scaleY,0,0];
            mRotate =  [Math.cos(a*Math.PI/180),Math.sin(a*Math.PI/180),-Math.sin(a*Math.PI/180),Math.cos(a*Math.PI/180),0,0];
            mTrans = [1,0,0,1,offsetX,offsetY];

            // 目标a 画布放大 x2
            ctx.save();
            ctx.setTransform(1,0,0,1,originX,originY);
            Transform(mScale);
            rect(width,height,'red');
            ctx.restore();

            //目标b 自身旋转 30；
            ctx.setTransform(1,0,0,1,originX,originY);

            mRotate =  [Math.cos(a*Math.PI/180),Math.sin(a*Math.PI/180),-Math.sin(a*Math.PI/180),Math.cos(a*Math.PI/180),0,0];

            mFinal = matrix.mul(mRotate,mFinal);
            Transform(mFinal);
            rect(width,height,'orange');

            //目标c, 画布旋转30， 自身旋转 30；
            ctx.setTransform(1,0,0,1,originX,originY);
            mRotate =  [Math.cos(a*Math.PI/180),Math.sin(a*Math.PI/180),-Math.sin(a*Math.PI/180),Math.cos(a*Math.PI/180),0,0];

            mFinal = [1,0,0,1,0,0];
            mFinal = matrix.mul(mTrans,mFinal);
            Transform(mFinal);
            rect(width,height,'black');


            ctx.setTransform(1,0,0,1,originX,originY);
            mFinal = [1,0,0,1,0,0];
            mFinal = matrix.mul(mRotate,mFinal);

            mFinal = matrix.mul(mTrans,mFinal);
            mFinal = matrix.mul(mRotate,mFinal);
            /*mFinal = matrix.mul(mFinal,mRotate,mFinal);*/
          /*  mFinal = matrix.mul(mFinal,mScale,mFinal);*/

            Transform(mFinal);
            rect(width,height,'green');


            m1 = [1,0,0,1,2,2];

            m2 = [1,0,0,1,2,2];

            mFinal = matrix.mul(m1,m2);

var kk =0;

      /*      while(a<360){
                //设原点



                ctx.setTransform(1,0,0,1,originX,originY);

                if(a==0){
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(0,0,width,height);
                    ctx.fill();
                }


                m1[0]=Math.cos(a * Math.PI/180);
                m1[1]=Math.sin(a*Math.PI/180);
                m1[2]=-Math.sin(a*Math.PI/180);
                m1[3]= Math.cos(a * Math.PI/180);
                m1[4]=( offsetX*Math.cos(a * Math.PI/180) - offsetY* Math.sin(a*Math.PI/180) );
                m1[5]=( offsetX*Math.sin(a * Math.PI/180) + offsetY* Math.cos(a*Math.PI/180) );

                mScale = [scaleX,0,0,scaleY,0,0];
                mRotate =  [Math.cos(a*Math.PI/180),Math.sin(a*Math.PI/180),-Math.sin(a*Math.PI/180),Math.cos(a*Math.PI/180),0,0];
                mTrans = [1,0,0,1,offsetX,offsetY];




                 mFinal = matrix.mul(mFinal,mRotate,mTrans);



                Transform(mFinal);
                Transform(mScale);



                ctx.fillStyle = 'red';
                ctx.fillRect(0,0,width,height);
                ctx.fill();
                a= a+ increase;
            }*/




           function Transform(matrix){
               var m = matrix;
                ctx.transform(m[0],m[1],m[2],m[3],m[4],m[5]);
            }

            function rect(width, height, color){
                ctx.fillStyle = color;
                ctx.fillRect(0,0,width,height);
                ctx.fill();

            }

        }
    </script>
</head>
<body>
<div id="div1">
    <canvas id="myCanvas" width="800" height="800"></canvas>
</div>
</body>
</html>